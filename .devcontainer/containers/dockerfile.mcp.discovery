# MCP Service Discovery & Health Monitoring Agent
# Real-time WebSocket health streaming
# Full development stack discovery and integration
# Container-based service registry

FROM node:22-alpine

LABEL maintainer="React Scuba Development Team"
LABEL description="MCP Service Discovery Agent with real-time health monitoring"
LABEL com.react-scuba.service="mcp-discovery"
LABEL com.react-scuba.tier="monitoring"

# Install dependencies
RUN apk add --no-cache \
    curl \
    docker-cli \
    jq \
    ca-certificates

# Create application directory
WORKDIR /app

# Initialize Node.js project and install dependencies
RUN npm init -y \
    && npm install --save \
    ws@8.18.0 \
    express@4.21.1 \
    axios@1.7.9 \
    dockerode@4.0.2

# Create MCP discovery agent
RUN cat > /app/discovery-agent.js <<'EOF'
const express = require("express");
const http = require("http");
const WebSocket = require("ws");
const axios = require("axios");
const Docker = require("dockerode");

const app = express();
const server = http.createServer(app);
const docker = new Docker({ socketPath: "/var/run/docker.sock" });

// WebSocket server attached to HTTP server
const wss = new WebSocket.Server({ server });

const healthCache = new Map();
const services = (process.env.MCP_SERVICES || "").split(",").filter(Boolean);

// Service discovery from Docker labels
async function discoverServices() {
  const containers = await docker.listContainers();
  const mcpServices = containers.filter(c =>
    c.Labels["com.react-scuba.discovery.enabled"] === "true"
  );

  return mcpServices.map(c => ({
    name: c.Names[0].replace("/", ""),
    service: c.Labels["com.react-scuba.service"],
    ip: c.NetworkSettings.Networks["react-scuba_mcp-cluster"]?.IPAddress,
    healthRealtime: c.Labels["com.react-scuba.health.realtime"] === "true"
  }));
}

// Health check with MCP protocol validation
async function checkServiceHealth(service) {
  const [host, port] = service.split(":");
  try {
    const response = await axios.get(`http://${host}:${port}/health`, { timeout: 5000 });
    return {
      service,
      status: "healthy",
      protocol: response.data.protocol || "unknown",
      version: response.data.version || "unknown",
      timestamp: new Date().toISOString()
    };
  } catch (error) {
    return {
      service,
      status: "unhealthy",
      error: error.message,
      timestamp: new Date().toISOString()
    };
  }
}

// Broadcast health updates to all WebSocket clients
function broadcastHealth(healthData) {
  wss.clients.forEach(client => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(JSON.stringify(healthData));
    }
  });
}

// Continuous health monitoring
async function monitorHealth() {
  const discovered = await discoverServices();

  for (const svc of [...services, ...discovered.map(d => `${d.ip}:9099`)]) {
    const health = await checkServiceHealth(svc);
    healthCache.set(svc, health);
    broadcastHealth(health);
  }
}

// HTTP endpoints
app.get("/health", (req, res) => {
  res.json({ status: "healthy", agent: "mcp-discovery" });
});

app.get("/services", async (req, res) => {
  const discovered = await discoverServices();
  res.json({ services: Array.from(healthCache.values()), discovered });
});

// WebSocket connection handler
wss.on("connection", (ws) => {
  console.log("WebSocket client connected");
  ws.send(JSON.stringify({ type: "connected", services: Array.from(healthCache.values()) }));
});

// Start server
server.listen(9097, () => {
  console.log("MCP Discovery Agent running on port 9097");
  setInterval(monitorHealth, 15000); // Check every 15s
  monitorHealth(); // Initial check
});
EOF

# Create health check script
RUN echo '#!/bin/sh\ncurl -f http://localhost:9097/health || exit 1' > /usr/local/bin/health-check \
    && chmod +x /usr/local/bin/health-check

# Expose WebSocket port
EXPOSE 9097

# Health check
HEALTHCHECK --interval=10s --timeout=3s --start-period=15s --retries=3 \
    CMD /usr/local/bin/health-check

# Run discovery agent
CMD ["node", "/app/discovery-agent.js"]
